[
{
	"uri": "https://swiftui.jokerhub.cn/tutorials/drawing_and_animation/drawing_paths_and_shapes/",
	"title": "绘制路径和形状",
	"tags": [],
	"description": "",
	"content": " 用户在浏览完一个地标后会得到一个徽章。但用户要得到徽章首先要先要创建一个徽章。本篇教程就是使用路径和形状创建徽章的过程，创建的徽章可以和其它图形组合形成位置标志。\n如果想要针对不同种类的地标创建不同的徽章，可以尝试改变徽章基本组成符号的重复次数、角度或大小。\n跟着教程一步步走，可以下载工程文件进行实践。\n  项目文件   DrawingPathsAndShapes.zip  (6486 ko)    第一节 创建徽章视图 创建徽章前需要使用SwiftUI的矢量绘画API创建一个徽章视图\n步骤1 选择文件-\u0026gt;新建-\u0026gt;文件，然后从iOS文件模板列表中选择SwiftUI View。点击下一步(Next)，输入文件名Badge后点击创建(Create)\n步骤2 调整Badge视图，暂时先让它显示\u0026rdquo;Badge\u0026rdquo;文本，一会儿再绘制徽章的形状\n第二节 绘制徽章背景 使用SwiftUI的图形API绘制一个徽章形状\n步骤1 查看在文件HexagonParameters.swift中的代码。HexagonParameters结构体定义了绘制徽章六边形形状的控制点参数。不需要修改这些绘制相关的数据，仅仅使用这些数据指定绘制徽章形状时，线段和曲线的控制点位置。\n步骤2 在Badge.swift文件中，绘制徽章的形状并使用fill修改器给六边形填充颜色，形成一个视图。使用路径可以把多条直线、曲线或其它绘制形状的基本笔划连成一个复杂的图形，就像形成徽章六边形背景这样.\n步骤3 给路径添加起点，move(to:)方法可以把绘图光标移动到绘图中的一点，准备\u0008绘制的起点\n步骤4 使用六边形的绘制参数数据HexagonParameters，依次绘制六边形的边，形成大致轮廓.addLine(to:)方法会使用当前绘图光标所在点为起点，方法参数中指定的点为终点绘制直线。目前六边形看\u0008起来有点问题，不过不要担心，这是意料中的事，下面的步骤做完，六边形的形状就会和开头显示的徽章的六边形形状一致了\n步骤5 使用addQuadCurve(to:control:)方法绘制\u0008贝塞尔曲线，让六边形的角变的更圆润些。\n步骤6 把徽章路径包裹在一个Geometry Reader中，这样徽章可以使用容器的大小，定义自己绘制的尺寸，这样就不需要硬编码绘制尺寸了(100)。当绘制区域不是正方形时，使用绘制区域的最小边长(长宽中哪个最小使用哪个)作为绘制徽章背景的边长，并保持徽章背景的长宽比为1:1\n步骤7 使用xScale和xOffset参数调整变量，把徽章几何绘图区域居中\u0008绘制出来\n步骤8 把黑色实心填充色改为渐变色，使徽章看上去和开始设计的样式一致\n步骤9 渐变色上再使用aspectRatio(_:contentMode:)修改器，让渐变色按内容\u0008宽高比进行成比例渐变填充。保持1:1的长宽比，徽章背景可以保持居中在徽章视图中，不管徽章视图本身是不是正方形\n第三节 绘制徽章符号 地标徽章中心有一个以地标App图标中的山峰图形改造形成的标志。山峰这个符号由两个形状组成，一个是表示山顶被雪覆盖的部分，另一个是山体。这里会使用有一定间距的两个局部三角形形状绘制这个徽章符号\n步骤1 把之前的徽章视图形状抽出来单独形成一个BadgeBackground视图，并生成一个新的视图文件BadgeBackground.swift\n步骤2 把BadgeBackground放在Badge的body属性中。\n步骤3 创建名为BadgeSymbol的自定义视图，这个视图是一个山峰的形状，把这个形状复制多次并按一定角度旋转多次拼成一个徽章的图案\n步骤4 使用\u0008pathAPI来绘制徽章符号的上半部分，试着调节spacing、topWidth、topHeight的系数，观察这些系数是怎么影响图形绘制的结果的\n步骤5 绘制徽章图案的下半部分，使用move(to:)把绘图光标移到另一个图形绘制的起点，绘制新的形状\n步骤6 用紫色填充徽章符号\n第四节 组合徽章的前景符号和背景形状 徽章设计思路是在背景形状上面再绘制多个有固定旋转角度的山峰符号。定义一个新的类型用于展示旋转一定角度的徽章符号，使用ForEach生成不同旋转角度的山峰符号，绘制在徽章背景上，从而形成最终的徽章。\n步骤1 创建RotatedBadgeSymbol视图封装旋转徽章符号，调整旋转的角度，并在预览视图中查看效果\n步骤2 在Badge.swift中，使用ZStack把徽章图标放在徽章背景层上面。此时会发现，徽章符号的尺寸相比徽章背景大了许多，这不符合最初设计的预期\n步骤3 缩放符号尺寸到合适的大小\n步骤4 使用ForEach复制多个徽章图标，按360度周解均分，每一个徽章符号都比前一个多旋转45度，这种就会形成一个类似太阳和徽章图标\n检查是否理解 问题1 GeometryReader的作用是什么?\nGeometryReader可以把父视图分割成网格，便于在屏幕上布局视图 GeometryReader可以动态的绘制、定位、缩放视图，不需要写死它们的尺寸。这样可以在不同尺寸的屏幕上复用已经写好的视图 使用GeometryReader可以自动识别\u0008应用视图层级上形状的类型和位置，例如: (圆)Circle  问题2 下面代码段布局后是哪一个图？\n    问题3 下面代码绘制出哪个图？\n    "
},
{
	"uri": "https://swiftui.jokerhub.cn/tutorials/swiftui_essentials/creating_and_combining_views/",
	"title": "创建和组合视图",
	"tags": [],
	"description": "",
	"content": " 这个教程指导你构建一个名为Landmarks(地标)的应用。这个应用的功能是可以发现并分享你喜欢的地标。首先从创建地标详情页开始。\nLandmarks使用栈来按层组合图片、文本等视图元素，从而布局页面。在视图中添加地图，需要引入MapKit组件，在你布局页面的过程中， Xcode可以提供实时的反馈，让你所做的改动立即转化成对应的代码实现。\n  项目文件   CreatingAndCombiningViews.zip  (785 ko)    第一节 创建新项目并体验画布 创建SwiftUI项目工程，体验画布、预览模式和SwiftUI模板代码\n要想在Xcode中预览画布中的视图或者与画布中的视图进行交互，要求你的Mac系统版本号不低于macOS Catalina 10.15\n步骤1 打开Xcode，在启动页面点击创建新工程或者在菜单中选择文件-\u0026gt;新建-\u0026gt;项目\n步骤2 在项目模板选择器中，选择iOS作为项目平台，选项单视图应用(Single View App)作为项目模板，并点击下一步(Next)\n步骤3 输入Landmarks作为项目名称，选择SwiftUI作为用户界面的创建方式，并点击下一步(Next)，在磁盘目录下选择一个位置用来存放新创建的工程项目\n步骤4 工程创建好并打开后，在文件导航器中，选择ContentView.swift文件，可以浏览一下SwiftUI视图的组成结构。默认情况下，SwiftUI的视图文件包含两个结构体(Struct) 第一个结构体遵循View协议，描述视图的内容和布局。第二个结构体声明为第一个视图的预览视图。\n步骤5 在画布(Canvas)上，点击恢复(Resume)按钮可以显示预览视图，也可以使用快捷键Command+Option+P\n如果工程中没有出现画布(Canvas)，可以选择菜单:编辑器(Editor) -\u0026gt; 编辑器和画布(Editor and Canvas) 打开画布进行预览\n 步骤6 在body属性内部，修改文字Hello World为其它的不同的文字，当你在改变代码的同时，预览视图也会实时的更新对应的内容变化\n第二节 定制文本视图(Text View) 可能通过修改代码来改变一个视图的显示样式，也可以通过检查器获取视图可修改属性，然后再写对应的代码改变样式。在创建应用的过程中，可以同时使用源码编辑器、画布或者检查器，无论当前使用的是哪一个工具编辑视图，代码会保持和这些编辑器展示的样式一致\n下面我们使用检查器来定制视图的显示样式\n步骤1 在预览视图中，按下Command键的同时点击控件，会弹出一个编辑弹层，然后选择检查器(Inspect), 编辑弹层显示所有可以定制的视图属性，选中的控件不同，可以定制的属性集合也不相同\n步骤2 使用检查器把文字更改为Turtle Rock，也就是在应用中显示的第一个地标的名称\n步骤3 改变字体修改器为Title，使用系统字体修饰文字，可以自动按照用户在设备中设置的字体偏好大小进行调整。定制SwiftUI视图所调用的方法被称为视图修改器(Modifiers)，修改器在原视图的基础上修改部分显示样式和属性，返回一个新的视图，这样就可以让多个修改器串连进行，形成水平方向的链式调用，或者垂直方向的堆叠调用\n步骤4 手动在代码中添加foregroundColor(.green) 属性修改器，就会把文字的颜色调整为绿色。代码是决定视图样式的根本，当我们使用检查器来改变或移除一个属性修改器时，Xcode也会在代码编辑器中同步改变或移除对应的修改器代码\n步骤5 在代码编辑器中，按下Command的同时点击Text单词也可以属性弹窗，从中选择检查器后，再点击Color弹出菜单，选择继承(Inherited)，让文字的颜色恢复成原来的黑色\n步骤6 当我们移除 foregroundColor(.green) 时，Xcode会自动更新你的代码来反映视图的实际显示状况\n第三节 使用栈来组合视图 上一节创建了标题视图，接下来要添加一些文本视图来描述地标所在州及所在公园的名称等其它详细信息\n创建SwiftUI视图就是在body属性中描述视图的内容、布局及行为，但body属性只返回单个视图，这时\u0008组合多个视图时可以把它们放入一个栈中，通过水平、垂直、前后嵌套多个视图完成视图组合，做为一个整体在body属性中返回\n这一节中，使用一个垂直栈，把标题放在包含公园详情的水平栈的上方，在水平栈中，布局公园详情相关的内容\n可以使用Xcode提供的结构化布局来把视图嵌套在容器视图中\n步骤1 按下Command键的同时，点击Text视图的初始化代码打开结构化编辑弹窗，然后选择把控件嵌套在垂直栈中(Embed in VStack)，在栈中添加Text View控件可以从组件中直接拖进栈中完成\n步骤2 点击Xcode右上角的+号，托动一个Text控件到指定位置，代码立即就会在编辑器中补全\n步骤3 把Text视图的占位文本修改为Joshua Tree Nation Park，视图会自动调整位置布局\n步骤4 设置位置控件的字体为子标题样式\n步骤5 设置VStack初始化参数为左对齐内部的子视图。默认情况下，栈会把内部视图在自己的主轴上居中对齐，并自动计算各子视图的间距。下一步要添加一个Text控制用来描述公园的状态，它水平排列在位置信息的右边。\n步骤6 在\u0008\u0008画布内，command按下的同时点击位置视图，在弹出的菜单中选择嵌入到水平栈中(Embed in HStack)\n步骤7 在位置控件的后面加一个公园状态的Text视图，并把占位文字改为California，字体设置为子标题样式\n步骤8 为了水平布局使用整个屏幕宽度，在位置控件和公园状态控件中间添加一个Spacer控件，用来填充两个控件中间的空白部分，并把两个控件分别顶向屏幕的两侧。Spacer是一个可以伸缩的空白控件，他负责占用其它控件布局完成后剩下的所有空间。\n步骤9 使用padding()修改器给地标信息内容视图整体加内边距\n第四节 创建自定义图像视图(Image) 有了地标名称、地标位置及状态视图，下一步再添加一个地标图片视图。这个图片视图将自定义遮罩(mask)、边框(border)和阴影(shadow)\n从控件加中拖一个Image到画布，或直接写代码到代码编辑器中\n步骤1 在项目资源文件中找到turtlerock.png图片，把它拖入资源编辑器(asset catalog editor)中，Xcode会创建一个新的图片集来存放这个图片，然后创建一个SwiftUI视图\n步骤2 选择文件-\u0026gt;新建-\u0026gt;文件，打开模板选择器。在用户界面(User Interface)板块下，选择SwiftUI View并点击下一步，命名为CircleImage.swift，并点击创建(Create)。现在你已经准备好插入图片并修改布局来满足设计目标\n步骤3 用Image替换Text，并使用turtlerock图片初始化Image视图\n步骤4 添加clipShape(Circle())修改器到Image，给图片添加圆形剪切效果。Circle是一个形状，它可以被用作遮罩、也可以是圆圈，还可以是圆形\u0008填充视图。\n步骤5 创建另一个灰色的圆圈并把它作为一个浮层添加到图片上，相当于给图片加了一个灰色边框\n步骤6 给视图添加半径为10的阴影\n步骤7 把圆形边框的颜色改成白色，就完成了自定义图片视图的创建。\n第五节 UIKit视图与SwiftUI视图混合使用 现在要创建一个地图视图，可以使用MapKit中的MKMapView视图类来渲染地图。要在SwiftUI中使用UIView及其子类，需要把这些UIView包裹在一个遵循UIViewRepresentable协议的SwiftUI视图中，SwiftUI中也包含适配WatchKit和AppKit的类似的协议。\n首先需要创建一个自定义视图用来容纳和显示MKMapView\n步骤1 选择文件-\u0026gt;新建-\u0026gt;文件，选择iOS平台，选择SwiftUI View模板，并点击下一步(Next)，命名文件为MapView.swift，并点击创建(Create)\n步骤2 代码中导入MapKit引用，声明MapView遵循UIViewRepresentable协议。UIViewRepresentable协议要求实现两个方法UIView(context:)和updateUIView(_:context:)，第一个方法用来创建MKMapView，第二个方法用来配置视图响应状态变化\n步骤3 替换body，用makeUIView(context:)方法来代替，创建并返回一个空的MKMapView\n步骤4 创建方法updateUIView(_:context:)，在方法内部设置地图视图的坐标为Turle Rock的中心。在静态模式下预览时，只会渲染swiftUI视图的部分，因为MKMapView是UIView的子类，所以需要切换到实时预览模式下才能看到地图被完全渲染出来\n步骤5 点击Live Preview(实时预览)按钮，可能需要点击Try Again和Resume按钮来激活预览模式的切换。切换到实时预览模式下不久就可以看到\u0008指定地标所在的地图位置了\n第六节 组合地标详情页 前面我们创建了个地标详情页所需要的各种子视图元素：名称、地点、圆形图片以及位置地图，现在可以把这些视图元素组合在一起形成地标详情页的整个视图\n 在项目工程浏览器中选择ContentView.swift文件\n body属性中嵌入一个VStack视图，它内部包含另一个VStack视图，内部的VStack视图又包含三个Text视图\n 在外层VStack的顶部添加自定义的地图视图MapView，并使用frame(width:height:)设置视图大小。当只指定高度时，宽度会自动计算为父视图的宽度，在这里就是屏幕宽度\n 点击Live Preview按钮进入实时预览模式，查看地图渲染情况。在实时预览模式下可以编辑视图，最新的改动也可以实时的刷新出来。\n 在MapView后面再添加一个CircleImage视图\n 为了让图片视图叠放在地图视图的上面，可以设置图片视图的垂直偏移量为-130，图片视图的底部内边距也为-130，这个效果就是把图片垂直上移了130，同时和下面的文字区域留出了130的空白分隔区\n 在外层VStack内部的最下面加上Spacer，可以让上面的视图内容顶到屏幕的上边\n 为了让地图的视图内容显示在状态栏的下方，可以给MapView添加edgesIgnoringSafeArea(.top)修改器，这可以让它在布局时忽略顶部的安全区域边距\n  检查是否理解 问题1 在声明自定义SwiftUI视图时，视图布局要声明的在哪里？\n在视图初始化器中 body属性中 layoutSubviews方法中  View协议中要求实现body属性，每一个SwiftUI视图都遵循View协议\n问题2 代码布局的视图是以下哪个？\n    问题3 下面哪种方法是从body属性中返回三个视图的正确方法？\n    问题4 配置视图时，下面哪种是正确使用修改器的方式？\n    修改器每次都是返回一个新的对象，所以多个修改器可以通过链式调用\n"
},
{
	"uri": "https://swiftui.jokerhub.cn/tutorials/drawing_and_animation/animating_views_and_transitions/",
	"title": "视图动画和转场",
	"tags": [],
	"description": "",
	"content": " 使用SwiftUI可以把视图状态的改变转成动画过程，SwiftUI会处理所有复杂的动画细节\n在这篇中，会给跟踪用户徒步的图表视图添加动画。\u0008使用animation(_:)修改器给一个视图添加动画效果非常容易\n下载起步项目并跟着本篇教程一步步实践，或者查看本篇完成状态时的工程代码去学习\n  项目文件   AnimatingViewsAndTransitions.zip  (6506 ko)    第一节 给每个视图单独添加动画 在视图上使用animation(_:)修改器时，SwiftUI会在视图的任何可进行动画的属性发生改变时产生对应的动画效果。视图的颜色、不透明度、旋转角度、大小及一些其它属性都是可进行动画的\n步骤1 在HikeView.swift中，打开实时预览，体验一下图表的打开和隐藏，此时的状态改变时是没有添加动画效果的。在本篇的实践中，保持实时预览一直打开，每一步修改的效果就可以实时的看到\n步骤2 给显示/隐藏切换的箭头按钮添加旋转动画，会发现现在按钮点击时的旋转有一个动画过渡的效果了\n步骤3 当视图从隐藏到展示时，让切换按钮变大1.5倍\n步骤4 把动画的类型从easeInOut改为spring()。SwiftUI包含一些预设或可自定义的动画类型，像弹簧(spring)动画和类型液体(fluid)动画类型。可以调整动画开始前的等待时长、动画的速度也可以指定让动画循环重复的进行\n步骤5 如果只想让按钮具有缩放动画而不进行旋转动画，可以在scaleEffect添加animation(nil)来实现。可以在这里做一些实验，如果把其它的一些动画效果结合在一起，会怎么样\n步骤6 学下一节之前，把本节中添加的animation(_:)修改器都去掉\n第二节 把视图的状态改态转化成动画效果 已经学会了给单个视图添加动画的方法，现在可以学习怎么在视图的状态发生改变时添加动画效果。当用户点击按钮时会切换showDetail状态的值，在视图变化过程中添加动画效果。\n步骤1 把showDetail.toggle()包裹在withAnimation函数调用块中。showDetail的改变影响了视图HikeDetail和详情切换按钮，在显示/隐藏详情的过程中都有了过滤动画效果。\n放慢动画速度，可以观察SwiftUI动画在被中断下是怎么运作的\n步骤2 给withAnimation传入一个时长4秒的基本动画参数.easeInOut(duration:4)，可以指定动画过程时长，给withAnimation传入的动画参数与.animation(_:)修改器可用参数一致。\n步骤3 在动画过程进行中点击按钮切换视图状态，查看对应的动画被中断时的效果\n步骤4 读下一节之前，把动画时长参数(.easeInOut(duration: 4))去掉，让动画不再缓慢进行。\n第三节 定制视图转场动画 默值情况下，视图离屏和入屏时的动画效果是渐隐/渐现， 这个默认的转场效果可以使用transition(_:)修改器进行定制。\n步骤1 给HikeView视图添加transition(_:)修改器，并定制转场参数为.slide，转场动画为滑入/滑出\n步骤2 可以把滑入/滑出这种转场动画封装起来，方便其它视图复用同样的转场效果\n步骤3 在moveAndFade转场效果的定义中使用move(edge:)，让滑入/滑出从屏幕的同一边进行\n步骤4 使用asymmetric(insertion:removal:)修改器来定制视图显示/消失时的转场动画效果\n第四节 组合复杂的动画效果 点击图表下面的三个按钮，会在三个不同的数据集间进行切换并展示。本节中会使用组合动画，让图表在不同数据集间切换时的转换动画流畅自然。\n步骤1 把showDetail的默认值改为true，并把HikeView的预览模式视图固定在画布上。这样可以在编辑其它文件时，依然看到动画效果的变化。\n步骤2 在HikeGraph.swift中定义了一个新的波动动画，并把它与滑入/滑出动画一起应用到图表视图上。\n步骤3 把动画切换为弹簧动画(spring)，并设置弹簧阻尼系数为0.5，动画过程中产生了逐渐回弹效果\n步骤4 加速弹簧动画的执行速度，缩短切换图表的时间\n步骤5 以当条形在图表中的位置为参数，添加延迟效果，图表中的每个条形会顺序动起来\n步骤6 观察一下自定义波动(rippling)效果是怎么作用在视图转场中的\n检查是否理解 问题1 怎样从一串动画效果调用中，去掉其中的一种动画效果。以下面的代码为例，怎样去掉旋转动画\n    问题2 当你开发动画的过程上，为什么要把预览视图固定在画布上？\n为了固定动画过程中的当前帧 为了在多个设备配置开发中预览动画效果 为了在切换到其它不同文件时，固定显示当前视图的预览  问题3 在视图状态改变时，如何快速测试一个动画在被中断时的表现\n在包含animation(_:)修改器的代码行上打一个断点，然后\u0008单步按动画帧进行测试 调整动画的持续时长，让动画在足够长的时间内完成，这样就可以调整动画的细节 重复的调用sleep(100)来减慢动画的执行  "
},
{
	"uri": "https://swiftui.jokerhub.cn/tutorials/swiftui_essentials/building_lists_and_navigation/",
	"title": "创建列表和导航",
	"tags": [],
	"description": "",
	"content": " 地标详情页视图已经创建完成，我们需要提供一种方式让用户可以查看完整的地标列表，并且可以查看每一个地标的详情\n下面会创建一个可以展示任何地标信息的视图，并动态生成一个可滚动列表，用户可以点击列表项去查看地标的详细\u0008信息。优化视图显示时，可以使用Xcode画布来渲染多个不同设备大小下的预览视图。\n下载下面的工程文件，并跟着教程一步步学习构建列表和视图间导航\n  项目文件   BuildingListsAndNavigation.zip  (6478 ko)    第一节 了解样本数据 前面的教程中，自\u0008定义视图所展示的信息都直接被写死在代码中，这篇教程中会学习给自定义视图传入样本数据进行展示\n步骤1 打开项目导航器，选择Models-\u0026gt;Landmark.swift文件，这个文件中声明了需要在应用中展示一个地标所需要信息的结构化名称，并通过导入landmarkData.json文件中的数据，生成一个地标信息数组。\n步骤2 在项目导航器中选择Resources-\u0026gt;landmarkData.json，在后面的教程中我们都会使用这个样本数据文件\n步骤3 注意，之前的ContentView视图，已经被改名为LandmarkDetail了，在本教程和后面的教程中，还会创建一些其它的视图\n第二节 创建行视图 本教程中创建的第一个视图就是用来显示每个地标的行视图，行视图把地标的相关信息存储在一个属性中，一行就可以代表一个地标，稍后就会把这些行组合成为一个列表。\n步骤1 创建一个名为LandmarkRow.swift的\u0008SwiftUI视图\n步骤2 如果预览视图没有出现，可以选择菜单编辑器-\u0026gt;画布，打开画布，并点击Resume进行预览，或者使用Command+Option+Enter快捷键调出画面，再使用Command+Option+P快捷键开始预览模式\n步骤3 添加landmark属性做为LandmarkRow视图的一个存储属性。当添加landmark属性后，预览视图可能会停止工作，因为LandmarkRow视图初始化时需要有一个landmark实例。要想修复预览视图，需要修改Preview Provider\n步骤4 在LandmarkRow_Previews的静态属性previews中给LandmarkRow初始化器中传入landmark参数，这个参数使用landmarkData数组的第一个元素。预览视图当前显示Hello, World\n步骤5 在一个HStack中嵌入一个Text\n步骤6 修改这个Text，让它使用landmark属性的name字段\n步骤7 在Text视图前面添加一个图片视图，在Text视图后面添加Spacer视图\n第三节 自定义行预览 Xcode的画布会自动识别当前代码编辑器中遵循PreviewProvider协议的类型，并将它们渲染并展示在画面上。一个视图预览提供者(preview provider)返回一个或多个视图，这些视图可以配置不同的大小和设备型号。\n可以定制从preview provider中返回的视图被渲染在何种场景下。\n步骤1 在LandmarkRow_Previews中，把landmark参数更新为landmarkData数组的第二个元素，预览视图会立即刷新反映第二个元素的渲染情况\n步骤2 使用previewLayout(_:)修改器设置一个行视图在列表中显示的尺寸大小。可以使用Group的方式，返回多个不同场景下的预览视图\n步骤3 把预览的行视图包裹在Group中，把之前的第一个行视图也加进去。Group是一个容器，它可以把视图内容组织起来，Xcode会把Group内的每个子视图当作画布内一个单独的预览视图处理\n步骤4 为了简化代码，可以把previewLayout(_:)这个修改器应用到外层的Group上，Group的每一个子视图会继承自己所处环境的配置。对preivew provider的修改只会影响预览画布的表现，对实际的应用不会产生影响。\n第四节 创建地标列表 使用SwiftUI列表类型可以展示平台相关的列表视图。列表的元素可以是静态的，类似于栈内部的子视图，也可以是动态生成的视图，也可以混合动态和静态的视图。\n步骤1 创建SwiftUI视图，命名为LandmarkList.swift\n步骤2 用List替换默认创建的Text，并将前两个LandmarkRow实例做为列表的子元素，预览视图中会以列表的形式展示出两个地标\n第五节 创建动态列表 \u0008除了单独列出列表中的每个元素外，列表还可以从一个集合中动态的生成。\n创建列表时可以传入一个集合\u0008\u0008数据和一个闭包，闭包会针对每一个数据元素返回一个视图，这个视图就是列表的行视图。\n步骤1 从列表中移除两个静态指定的行视图，给列表初始化器传入landmarkData数据，列表要配合可辨别的数据类型使用。想让数据变成可辨别的数据类型有两种方法:\n 传入一个keypath指定数据中哪一个字段用来唯一标识这个数据元素。\n 让数据遵循Identifiable协议\n  步骤2 在闭包中返回一个LandmarkRow视图，List初始化器中指定数据集合landmarkData和唯一标识符keypath:\\.id，这样列表就会动态生成，如下图所示\n步骤3 切换到文件Landmark.swfit，声明Landmark类型遵循Identifiable协议，因为Landmark类型已经定义了id属性，正好满足Identifiable协议，所以不需要添加其它代码\n步骤4 现在切换回文件LandmarkList.swift，移除keypath\\.id，因为landmarkData数据集合的元素已经遵循了Identifiable协议，所以在列表初始化器中可以直接使用，不需要手动标明数据的唯一标识符了\n第六节 设置从列表页到详情页的页面导航 地标列表可以正常渲染展示，但是列表的元素点击后没有反应，跳转不到地标详情页。现在就要给列表添加导航能力，把列表视图嵌套到NavigationView视图中，然后把列表的每一个行视图嵌套进NavigationLink视图中，就可以建立起从地标列表视图到地标详情页的跳转。\n步骤1 把动态生成的列表视图嵌套进一个NavigationView视图中\n步骤2 调用navigationBarTitle(_:)修改器设置地标列表显示时的导航条标题\n步骤3 在列表的闭包中，将每一个行元素包裹在NavigationLink中返回，并指定LandmarkDetail视图为目标视图\n步骤4 切换到实时预览模式下可以直接点击地标列表的任意一行，现在就可以跳转到地标详情页了。\n第七节 子视图传入数据 LandmarkDetail视图目前还是使用写死的数据进行展示，与LandmarkRow视图一样，LandmarkDetail视图及它内部的子视图也需要传入landmark数据，并使用它来进行实际的展示\n从LandmarkDetail的子视图(CircleImage、MapView)开始，需要把它们都改造成为使用传入的数据进行展示，而不是在布局代码中写死数据展示\n步骤1 在CircleImage.swift文件中，添加一个存储属性，命名为image。这是一种在构建SwiftUI视图中很常用的模式，常常会包裹或封装一些属性修改器。\n步骤2 更新CirleImage的预览结构体，并传入Turtle Rock这个图片进行预览\n步骤3 在MapView.swift中添加一个coordinate属性，并使用这个属性来替换写死的\u0008经纬度坐标\n步骤4 更新MapView的预览结构体，并传入每一个地标的经纬度数据\n步骤5 在LandmarkDetail.swift中添加landmark属性。\n步骤6 更新LandmarkDetail预览结构体，并传入第一个地标的数据\n步骤7 把对应子视图的数据传入\n步骤8 最后调用navigationBarTitle(_:displayMode:)修改器为地标详情页展示时在导航条上设置一个标题\n步骤9 在SceneDelegate.swift中把应用的根视图替换为LandmarkList。应用在模拟器中独立启动时使用SceneDelegate的根视图做为第一个展示的视图\n步骤10 在LandmarkList.swift中，传入当前行的地标数据到地标详情页LandmarkDetail\n步骤11 切换到实时预览模式下去查看从地标列表页对应的行跳转到对应地标详情页是否正常\n第八节 动态生成预览视图 接下来要在不同尺寸设备上展示不同的预览视图，默认情况下，预览视图会选择当前Scheme选中的设备尺寸进行渲染，可以使用previewDevice(_:)修改器来改变预览视图的设备\n步骤1 改变当前预览列表，让它渲染在iPhone SE设备上。可以使用Xcode Scheme菜单上的设备名称来指定渲染设备。\n步骤2 在列表的预览视图中，还可以把LandmarkList嵌套进入ForEach实例中，使用设备数组名作为数据。ForEach运算作用在集合类型的数据上，就和列表使用集合类型数据一样，可以在子视图使用的任何场景下使用ForEach，例如：stack、list、group等。当元素数据是简单值类型时(例如字符串类型)，可以使用\\.self作为keypath去标识\n步骤3 使用previewDisplayName(_:)修改器可以给预览视图添加设备标签\n步骤4 可以在画布上多设置几个设备进行预览，比较不同设备下视图的展示情况\n检查是否理解 问题1 除了List外，下面哪种类型可以从集合数据中展示动态列表视图\nGroup ForEach UITableView  问题2 可以从遵循了Identifiable协议的集合数据创建列表视图。但如果集合数据不遵循Identifiable协议，还有什么办法可以创建列表视图？\n在集合数据上调用map(_:)方法 在集合数据上调用sorted(by:)方法 给List(_:id:)类型传入集合数据的同时，使用keypath指定一个唯一标识符字段  问题3 使用什么类型才能让列表的行实现点击跳转到其它视图页面？\nNavigationLink UITableViewDelegate NavigationView  问题4 下面哪种方式不是用来设置预览设备的？\n改变活动scheme中选中的模拟器 在画面设置中设置一个不同的预览设备 使用previewDevice(_:)指定一个或多个预览设备 连接开发机并点击设备预览按钮  "
},
{
	"uri": "https://swiftui.jokerhub.cn/tutorials/swiftui_essentials/handling_user_input/",
	"title": "处理用户输入",
	"tags": [],
	"description": "",
	"content": " 在Landmark应用中，标记喜爱的地方，过滤地标列表，只显示喜欢的地标。要增加这些特性，首先要在列表上添加一个开关，用来过滤用户喜欢的地标。在地标上添加一个星标按钮，用户可以点击它来标记这个地标为自己喜欢的。\n下载工程文件并且跟着下面的教程实践\n  项目文件   HandlingUserInput.zip  (6485 ko)    第一节 标记用户最喜欢的地标 给地标列表的每一行添加一个星标用来表示用户是否标记该地标为自己喜欢的\n步骤1 打开工程项目，在项目导航下选择LandmarkRow.swift文件\n步骤2 在空白占位后面添加一个if表达式，if表达\u0008式判断是否当前地标是用户喜欢的，如果用户标记当前地标为喜欢就显示星标。可以在SwitUI的代码\u0008块中使用if语句来条件包含视图\n步骤3 由于系统图片是\u0008矢量类型的，可以使用foregroundColor(_:)来改变它的颜色。当地标landmark的isFavorite属性为真时，星标显示，稍后会\u0008讲怎么修改属性值。\n第二节 过滤列表 可以定制地标列表，让它只显示用户喜欢的地标，或者显示所有的地标。要实现这个功能，需要给LandmarkList视图类型添加一些状态变量。\n状态(State)是一个值或者一个值的集合，会\u0008随着时间而改变，同时会影响视图的内容、行为或布局。在属性前面加上@State修饰词就是给视图添加了一个状态值\n步骤1 选择LandmarkList.swift文件，并给LandmarkList添加一个名为showFavoritesOnly的状态，初始值设置为false\n步骤2 点击Resume按钮或快捷键Command+Option+P刷新画布。当对视图进行添加或修改属性等结构性改变时，需要手动刷新画布\n步骤3 代码中通过检查showFavoritesOnly属性和每一个地标的isFavorite属性值来过滤地标列表所展示的内容\n第三节 添加控件来切换状态 为了让用户控制地标列表的过滤器，需要添加一个可以修改showFavoritesOnly值的控件，传递一个绑定关系给toggle控件可以实现\n一个绑定关系(binding)是对可变状态的引用。当用户点击toggle控件，从开到关或从关到开，toggle控件会通过绑定关系对应的更新视图的状态\n步骤1 创建一个嵌套的ForEach组来把地标数据转换成地标行视图。在一个列表中组合静态和动态视图，或者组合两个甚至多个不同的动态视图组，使用ForEach类型动态生成而不是给列表传入数据集合生成列表视图\n步骤2 添加一个Toggle视图作为列表的每一个子视图，传入一个showFavoritesOnly的绑定关系。使用$前缀来获得一个状态变量或属性的绑定关系\n步骤3 实时预览模式下，点击Toggle控件来验证过滤器的功能\n第四节 使用可观察对象来存储数据 要实现用户标记哪个地标为自己喜爱的地标这个功能，需要使用可观察对象(observalble object)存放地标数据\n可观察对象是一种可以绑定到具体SwifUI视图环境中的数据对象。SwiftUI可以察觉它影响视图展示的任何变化，并在这种变化发生后及时更新对应视图的展示内容\n步骤1 创建一个名为UserData.swift的文件\n步骤2 声明一个遵循ObservableObject协议的新数据模型，ObservableObject协议来自\u0008\u0008响应式框架Combine。SwiftUI可以订阅可观察对象，并在数据发生改变时更新视图的显示内容\n步骤3 添加存储属性showFavoritesOnly和landmarks，并赋予初始值。可观察对象需要对外公布内部数据的任何改动，因此订阅此可观察对象的订阅者就可以获得对应的数据改动信息\n步骤4 给新建的数据模型的每一个属性添加@Published属性修饰词\n第五节 视图中适配数据模型对象 已经创建了UserData可观察对象，现在要改造视图，让它使用这个新的数据模型来存储视图内容数据\n步骤1 在LandmarkList.swift文件中，使用@EnvironmentObject修饰的userData属性来替换原来的showFavoritesOnly状态属性，并对预览视图调用environmentObject(_:)修改器。只要environmentObject(_:)修改器应用在视图的父视图上，userData就能够自动获取它的值。\n步骤2 替换原来使用showFavoritesOnly状态属性的地方，改为使用userData中的对应属性。与@State修饰的属性一样，也可以使用$前缀访问userData对象的成员绑定引用\n步骤3 创建ForEach实例时使用userData.landmarks做为数据源\n步骤4 在SceneDelegate.swift中，对LandmarkList视图调用environmentObject修改器，这样可以把UserData的数据对象绑定到LandmarkList视图的环境变量中，子视图可以获得父视图环境中的变量。此时如果在模拟器或者真机上运行应用，也可以正常展示视图内容\n步骤5 更新LandmarkDetail视图，让它从父视图的环境变量中取要展示的数据。之后在更新地标的用户喜爱状态时，会用到landmarkIndex这个变量\n步骤6 切换到LandmarkList.swift文件，并打开实时预览视图去验证所添加的功能是否正常工作\n第六节 为每一个地标创建一个喜爱按钮 Landmark这个应用可以在喜欢和不喜欢的地标列表间进行切换了，但喜欢的地标列表还是硬编码形成的，为了让用户可以自己标记哪个地标是自己喜欢的，需要在地标详情页添加一个标记喜欢的按钮\n步骤1 在LandmarkDetail.swift的HStack中添加地标名称的Text\n步骤2 在地标名称的Text控件旁边添加一个新的按钮控件。使用if-else条件语句设置不同的图片显示状态表示这个地标是否被用户标记为喜欢。在Button的动作闭包中，使用了landmarkIndex去修改userData中对应地标的数据。\n步骤3 切换到landmarkList.swift，并开启实时预览模式。当从列表页导航进入详情页后，点击喜欢按钮，喜欢的状态会在返回列表页后与列表中对应的地标喜欢状态保持一致，因为列表页和详情页的地标数据使用的是同一份，所以可以在不同页面间保持状态同步。\n检查是否理解 问题1 下列选项哪个可以把数据按视图层级关系传递下去？\n@EnvironmentObject属性 environmentObject(_:)修改器  问题2 绑定(binding)的作用是什么？\n绑定是值和改变值的方法 是一个视图连接在一起的方法，确保连续起来的视图接收同一份数据 是一个临时固化值的方式，目的是在其它视图状态变化时，保持值不改变  "
},
{
	"uri": "https://swiftui.jokerhub.cn/tutorials/swiftui_essentials/",
	"title": "SwiftUI基础",
	"tags": [],
	"description": "",
	"content": " 学习使用SwiftUI把简单的视图组合成复杂的页面、建立数据流以及页面间的导航，同时在Xcode中预览效果\n包含章节  创建和组合视图   创建列表和导航   处理用户输入   "
},
{
	"uri": "https://swiftui.jokerhub.cn/tutorials/",
	"title": "SwiftUI教程",
	"tags": [],
	"description": "",
	"content": " SwiftUI是在苹果设备上创建用户界面的一种现代方法。可以更快的创建漂亮且充满活力的应用。\n只需要描述一次布局 声明式描述任何状态下的视图内容和布局。SwiftUI知道视图何时发生状态改变，并及时刷新对应状态下的视图内容。\n构建可复用组件 把多个目标单一的小视图组合成功能复杂的大视图进而组合成复杂的用户界面。同时自定义的视图还可以在不同的\u0008苹果平台设备应用开发中复用。\n简化动画效果实现 创建流畅的动画效果仅仅需要添加一个方法调用就可以完成。SwiftUI负责在必要时进行动画效果的内部计算和转场处理。\nXcode中实时预览 不需要实际运行应用就可以完成设计、构建和测试工作。使用交互式的预览功能来测试你开发的控件和页面布局。\n"
},
{
	"uri": "https://swiftui.jokerhub.cn/tutorials/drawing_and_animation/",
	"title": "绘制和动画",
	"tags": [],
	"description": "",
	"content": " 学习绘制形状和路径，并创建徽章和添加动画\n包含章节  绘制路径和形状   视图动画和转场   "
},
{
	"uri": "https://swiftui.jokerhub.cn/tutorials/app_design_and_layout/",
	"title": "应用设计与布局",
	"tags": [],
	"description": "",
	"content": " 深入了解使用SwiftUI创建的复杂的用户界面的结构和布局\n包含章节  "
},
{
	"uri": "https://swiftui.jokerhub.cn/tutorials/framework_integration/",
	"title": "框架集成",
	"tags": [],
	"description": "",
	"content": " 混合使用SwiftUI框架和平台相关的其它UI框架(视图和视图控制器)\n包含章节  "
},
{
	"uri": "https://swiftui.jokerhub.cn/",
	"title": "SwiftUI 概述",
	"tags": [],
	"description": "",
	"content": " SwiftUI 使用更少的代码创建更好的应用 SwiftUI是一种使用Swift语言在苹果设备上构建用户界面的创新且简单的方式。使用SwiftUI在\u0008苹果设备上创建用户界面可以使用一套统一的工具和API。SwiftUI使用声明式的Swift语法，代码易读并且写起来很自然。同时它可以和Xcode中的设计工具配合使用，让设计工具中的展示样式和代码同步起来。使用SwiftUI创建的用户界面自动支持了动态类型(Dynamic Type)、暗黑模式(Dark Mode)、语言本地化(Localization)以及所有人都可以使用的可访问性(Accessibility)，也就是说，创建用户界面时，SwiftUI写的代码比使用其它方式写的代码具有更多的功能。\n声明式语法 SwiftUI使用声明式的语法，可以非常简单的描述用户界面的样式。如果想要创建一个列表，列表中的每一项都包含文本，每一个文本都要设置不同的对齐方式、字体样式、文字颜色，使用SwiftUI来实现这样一个界面所写的代码比之前更加简\u0008单、易读，可以节省时间和维护成本。\n这种声明式的语法甚至可以应用到像动画这种复杂的概念中。只需要短短几行代码，就可以把一系列动画效果应用到任何控件上。为了保证应用的稳定运行，动画在执行过程中的细节由系统负责处理。添加动画效果变的非常容易，这样应用就可以添加各种动画效果，让整个应用变的充满活力。\n设计工具 Xcode 11提供了配合SwiftUI的新设计工具，它比较直观，可以通过拖拽的方式创建用户界面。在设计工具的画布中创建用户界面时，代码编辑器中可以同步自动创建出对应的代码。当设计发生更变时，Xcode会及时的重新编译并展示在预览视图中，可以随时修改，所见即所得。\n拖拽 就是在设计工具的画布上拖放控件，可视化的布局界面。点击控件打开检查器(inspector)后，可选择不同的字体、颜色、对齐方式以及其它设计选项，也可以使用鼠标拖动布局控件。这些可视化的编辑器有一部分也可以在代码编辑器中使用，\u0008即使你更喜欢手写代码来创建用户界面，也可以使用检查器(inspector)来了解控件属性和样式修改器。可以直接从控件库中拖控件到设计工具的画布上，也可以直接写代码来布局界面。\n动态替换 Swift的编译器和运行时环境完全嵌入在Xcode中，应用可以实时编译并运行，设计工具中画布展示的样子就是真实运行时的用户界面。使用Swift动态替换的新特性，Xcode可以直接让修改后的代码在实时预览模式\u0008下展示出来。\n预览 对于SwiftUI创建的视图，使用不同样本数据，可以创建一个甚至多个不同场景下的预览，这些预览可以针对任何设备类型或设备方向进行。\n所有苹果设备原生支持SwiftUI 苹果沉淀了十几年用户界面创建经验，SwiftUI就建立在这些经验之上。用户在\u0008\u0008\u0008苹果生态下的独特体验被完美的融入在SwiftUI的代码设计中。SwiftUI是原生支持的，这就是说通过写少量的代码或者使用设计工具在画布上设计就可以使用苹果各\u0008硬件平台提供的已有技术和功能。\n"
},
{
	"uri": "https://swiftui.jokerhub.cn/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://swiftui.jokerhub.cn/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]